(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{470:function(s,a,t){"use strict";t.r(a);var e=t(10),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("blockquote",[t("p",[s._v("专栏原创出处："),t("a",{attrs:{href:"https://github.com/GourdErwa/review-notes/tree/master/framework/flink-basis",target:"_blank",rel:"noopener noreferrer"}},[s._v("github-源笔记文件 "),t("OutboundLink")],1),s._v(" ，"),t("a",{attrs:{href:"https://github.com/GourdErwa/flink-advanced",target:"_blank",rel:"noopener noreferrer"}},[s._v("github-源码 "),t("OutboundLink")],1),s._v("，欢迎 Star，转载请附上原文出处链接和本声明。\n本内容主要参考 "),t("a",{attrs:{href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/concepts/runtime.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("flink-runtime"),t("OutboundLink")],1),s._v(" 整理")])]),s._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#_1-任务和算子链"}},[s._v("1 任务和算子链")])]),t("li",[t("a",{attrs:{href:"#_2-job-managers、task-managers、客户端-clients"}},[s._v("2 Job Managers、Task Managers、客户端（Clients）")])]),t("li",[t("a",{attrs:{href:"#_3-task-slots-和资源"}},[s._v("3 Task Slots 和资源")])]),t("li",[t("a",{attrs:{href:"#_4-state-backends"}},[s._v("4 State Backends")])]),t("li",[t("a",{attrs:{href:"#_5-savepoints"}},[s._v("5 Savepoints")])])])]),t("p"),s._v(" "),t("h2",{attrs:{id:"_1-任务和算子链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-任务和算子链"}},[s._v("#")]),s._v(" 1 任务和算子链")]),s._v(" "),t("p",[s._v("分布式计算中，Flink 将算子（operator）的 subtask 链接（chain）成 task。"),t("br"),s._v("\n每个 task 由一个线程执行。"),t("br"),s._v("\n把算子链接成 tasks 能够减少线程间切换和缓冲的开销，在降低延迟的同时提高了整体吞吐量。"),t("br"),s._v("\n链接操作的配置详情可参考："),t("a",{attrs:{href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/stream/operators/#task-chaining-and-resource-groups",target:"_blank",rel:"noopener noreferrer"}},[s._v("chaining docs"),t("OutboundLink")],1)]),s._v(" "),t("p",[s._v("下图的 dataflow 由五个 subtasks 执行，因此具有五个并行线程。"),t("br")]),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/framework/flink-basis/_images/tasks_chains.png",height:"450px"}})]),t("p"),s._v(" "),t("h2",{attrs:{id:"_2-job-managers、task-managers、客户端-clients"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-job-managers、task-managers、客户端-clients"}},[s._v("#")]),s._v(" 2 Job Managers、Task Managers、客户端（Clients）")]),s._v(" "),t("p",[s._v("Flink 运行时包含两类进程：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("JobManagers")]),s._v(" （也称为 masters）协调分布式计算\n它们负责调度任务、协调 checkpoints、协调故障恢复等。")])]),s._v(" "),t("p",[s._v("每个 Job 至少会有一个 JobManager。高可用部署下会有多个 JobManagers，其中一个作为 leader，其余处于 standby 状态。")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("TaskManagers")]),s._v("（也称为 workers）执行 dataflow 中的 tasks（准确来说是 subtasks ），并且缓存和交换数据 streams。")])]),s._v(" "),t("p",[s._v("每个 Job 至少会有一个 TaskManager。")]),s._v(" "),t("p",[s._v("JobManagers 和 TaskManagers 有多种启动方式：直接在机器上启动（该集群称为 standalone cluster），在容器或资源管理框架，如 YARN 或 Mesos，中启动。TaskManagers 连接到 JobManagers，通知后者自己可用，然后开始接手被分配的工作。")]),s._v(" "),t("p",[s._v("客户端虽然不是运行时（runtime）和作业执行时的一部分，但它是被用作准备和提交 dataflow 到 JobManager 的。提交完成之后，客户端可以断开连接，也可以保持连接来接收进度报告。客户端既可以作为触发执行的 Java / Scala 程序的一部分，也可以在命令行进程中运行./bin/flink run ...。")]),s._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/framework/flink-basis/_images/processes.png",height:"550px"}})]),s._v(" "),t("h2",{attrs:{id:"_3-task-slots-和资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-task-slots-和资源"}},[s._v("#")]),s._v(" 3 Task Slots 和资源")]),s._v(" "),t("p",[s._v("每个 worker（TaskManager）都是一个 JVM 进程，并且可以在不同的线程中执行一个或多个 subtasks。"),t("br"),s._v("\n为了控制 worker 接收 task 的数量，worker 拥有所谓的 task slots （至少一个）。")]),s._v(" "),t("p",[s._v("每个 task slots 代表 TaskManager 的一份固定资源子集。"),t("br"),s._v("\n例如，具有三个 slots 的 TaskManager 会将其管理的内存资源分成三等份给每个 slot。 划分资源意味着 subtask 之间不会竞争资源，但是也意味着它们只拥有固定的资源。注意这里并没有 CPU 隔离，当前 slots 之间只是划分任务的内存资源。")]),s._v(" "),t("p",[s._v("通过调整 slot 的数量，用户可以决定 subtasks 的隔离方式。每个 TaskManager 有一个 slot 意味着每组 task 在一个单独的 JVM 中运行（例如，在一个单独的容器中启动）。拥有多个 slots 意味着多个 subtasks 共享同一个 JVM。"),t("br"),s._v("\nTasks 在同一个 JVM 中共享 TCP 连接（通过多路复用技术）和心跳信息（heartbeat messages）。它们还可能共享数据集和数据结构，从而降低每个 task 的开销。")]),s._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/framework/flink-basis/_images/tasks_slots.png",height:"300px"}})]),s._v(" "),t("p",[s._v("默认情况下，Flink 允许 subtasks 共享 slots，即使它们是不同 tasks 的 subtasks，只要它们来自同一个 job。因此，一个 slot 可能会负责这个 job 的整个管道（pipeline）。允许 slot sharing 有两个好处：")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("Flink 集群需要与 job 中使用的最高并行度一样多的 slots。这样不需要计算作业总共包含多少个 tasks（具有不同并行度）。")])]),s._v(" "),t("li",[t("p",[s._v("更好的资源利用率。在没有 slot sharing 的情况下，简单的 subtasks（source/map()）将会占用和复杂的 subtasks （window）一样多的资源。通过 slot sharing，将示例中的并行度从 2 增加到 6 可以充分利用 slot 的资源，同时确保繁重的 subtask 在 TaskManagers 之间公平地获取资源。")])])]),s._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/framework/flink-basis/_images/slot_sharing.png",height:"400px"}})]),s._v(" "),t("p",[s._v("APIs 还包含了 "),t("a",{attrs:{href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/stream/operators/#task-chaining-and-resource-groups",target:"_blank",rel:"noopener noreferrer"}},[s._v("resource group"),t("OutboundLink")],1),s._v(" 机制，它可以用来防止不必要的 slot sharing。")]),s._v(" "),t("p",[s._v("根据经验，合理的 slots 数量应该和 CPU 核数相同。在使用超线程（hyper-threading）时，每个 slot 将会占用 2 个或更多的硬件线程上下文（hardware thread contexts）。")]),s._v(" "),t("h2",{attrs:{id:"_4-state-backends"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-state-backends"}},[s._v("#")]),s._v(" 4 State Backends")]),s._v(" "),t("p",[s._v("key/values 索引存储的数据结构取决于 "),t("a",{attrs:{href:"https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/ops/state/state_backends.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("state backend"),t("OutboundLink")],1),s._v(" 的选择。"),t("br"),s._v("\n一类 state backend 将数据存储在内存的哈希映射中，另一类 state backend 使用 "),t("a",{attrs:{href:"http://rocksdb.org/",target:"_blank",rel:"noopener noreferrer"}},[s._v("RocksDB"),t("OutboundLink")],1),s._v(" 作为键/值存储。"),t("br"),s._v("\n除了定义保存状态（state）的数据结构之外， state backend 还实现了获取键/值状态的时间点快照的逻辑，并将该快照存储为 checkpoint 的一部分。")]),s._v(" "),t("div",{attrs:{align:"center"}},[t("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/framework/flink-basis/_images/checkpoints.png",height:"400px"}})]),s._v(" "),t("h2",{attrs:{id:"_5-savepoints"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-savepoints"}},[s._v("#")]),s._v(" 5 Savepoints")]),s._v(" "),t("p",[s._v("用 Data Stream API 编写的程序可以从 savepoint 继续执行。Savepoints 允许在不丢失任何状态的情况下升级程序和 Flink 集群。")]),s._v(" "),t("p",[s._v("Savepoints 是手动触发的 checkpoints，它依靠常规的 checkpoint 机制获取程序的快照并将其写入 state backend。在执行期间，程序会定期在 worker 节点上创建快照并生成 checkpoints。对于恢复，Flink 仅需要最后完成的 checkpoint，而一旦完成了新的 checkpoint，旧的就可以被丢弃。")]),s._v(" "),t("p",[s._v("Savepoints 类似于这些定期的 checkpoints，除了它们是由用户触发并且在新的 checkpoint 完成时不会自动过期。你可以通过命令行 或在取消一个 job 时通过 REST API 来创建 Savepoints。")])])}),[],!1,null,null,null);a.default=r.exports}}]);