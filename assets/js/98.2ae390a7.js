(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{305:function(i,v,t){"use strict";t.r(v);var _=t(0),a=Object(_.a)({},(function(){var i=this,v=i.$createElement,t=i._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[t("blockquote",[t("p",[i._v("专栏原创出处："),t("a",{attrs:{href:"https://github.com/GourdErwa/review-notes/tree/master/language/java-concurrency",target:"_blank",rel:"noopener noreferrer"}},[i._v("github-源笔记文件 "),t("OutboundLink")],1),i._v(" ，"),t("a",{attrs:{href:"https://github.com/GourdErwa/java-advanced/tree/master/java-concurrency",target:"_blank",rel:"noopener noreferrer"}},[i._v("github-源码 "),t("OutboundLink")],1),i._v("，欢迎 Star，转载请附上原文出处链接和本声明。")])]),i._v(" "),t("p",[i._v("Java 并发编程专栏系列笔记，系统性学习可访问个人复盘笔记-技术博客 "),t("a",{attrs:{href:"https://review-notes.top/language/java-concurrency/",target:"_blank",rel:"noopener noreferrer"}},[i._v("Java 并发编程 "),t("OutboundLink")],1)]),i._v(" "),t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#知识回顾"}},[i._v("知识回顾")])]),t("li",[t("a",{attrs:{href:"#比较"}},[i._v("比较")])])])]),t("p"),i._v(" "),t("h2",{attrs:{id:"知识回顾"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#知识回顾"}},[i._v("#")]),i._v(" 知识回顾")]),i._v(" "),t("p",[i._v("本节内容需要基础知识点如下，可参考本专栏文章：")]),i._v(" "),t("ul",[t("li",[i._v("《线程等待通知机制（wait、notify）》")]),i._v(" "),t("li",[i._v("《锁相关工具类（LockSupport）》")]),i._v(" "),t("li",[i._v("《锁等待通知机制（Condition）》")])]),i._v(" "),t("p",[i._v("我们可以把线程的等待通知机制看着是线程的通信交流，执行某一块代码时，因为条件不满足进入等待状态，其他线程修改条件后唤醒继续执行。")]),i._v(" "),t("p",[i._v("本节内容为个人学习理解整理，可能存在偏差，欢迎讨论。")]),i._v(" "),t("h2",{attrs:{id:"比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#比较"}},[i._v("#")]),i._v(" 比较")]),i._v(" "),t("ul",[t("li",[t("p",[i._v("实现原理（底层）")]),i._v(" "),t("ul",[t("li",[i._v("sleep：native 方法，内核定时器触发")]),i._v(" "),t("li",[i._v("wait：native 方法，配合 synchronized 的 monitorenter 和 monitorexit 指令")]),i._v(" "),t("li",[i._v("park：native 方法，二元信号量")]),i._v(" "),t("li",[i._v("Condition：AQS 维护等待队列与同步队列")])])]),i._v(" "),t("li",[t("p",[i._v("编码操作")]),i._v(" "),t("ul",[t("li",[i._v("sleep：Thread.sleep 静态方法")]),i._v(" "),t("li",[i._v("wait：使用 synchronized 加锁的对象，Object 的 wait/notify")]),i._v(" "),t("li",[i._v("park：LockSupport.park/unpark")]),i._v(" "),t("li",[i._v("Condition：由 Lock 对象 newCondition 方法创建，wait/signal")])])]),i._v(" "),t("li",[t("p",[i._v("等待时是否释放锁")]),i._v(" "),t("ul",[t("li",[i._v("sleep：不释放")]),i._v(" "),t("li",[i._v("wait：释放")]),i._v(" "),t("li",[i._v("park：释放")]),i._v(" "),t("li",[i._v("Condition：释放")])])]),i._v(" "),t("li",[t("p",[i._v("超时等待")]),i._v(" "),t("ul",[t("li",[i._v("sleep：支持")]),i._v(" "),t("li",[i._v("wait：支持")]),i._v(" "),t("li",[i._v("park：支持")]),i._v(" "),t("li",[i._v("Condition：支持")])])]),i._v(" "),t("li",[t("p",[i._v("等待过程中断")]),i._v(" "),t("ul",[t("li",[i._v("sleep：支持")]),i._v(" "),t("li",[i._v("wait：支持")]),i._v(" "),t("li",[i._v("park：支持")]),i._v(" "),t("li",[i._v("Condition：支持")])])]),i._v(" "),t("li",[t("p",[i._v("唤醒操作")]),i._v(" "),t("ul",[t("li",[i._v("sleep：不支持，定时器唤醒")]),i._v(" "),t("li",[i._v("wait：支持，notify/notifyAll")]),i._v(" "),t("li",[i._v("park：支持，unpark")]),i._v(" "),t("li",[i._v("Condition：支持，signal/signalAll")])])]),i._v(" "),t("li",[t("p",[i._v("等待操作精准性")]),i._v(" "),t("ul",[t("li",[i._v("sleep：当前线程")]),i._v(" "),t("li",[i._v("wait：当前线程")]),i._v(" "),t("li",[i._v("park：指定具体的线程")]),i._v(" "),t("li",[i._v("Condition：当前线程")])])]),i._v(" "),t("li",[t("p",[i._v("唤醒操作精准性")]),i._v(" "),t("ul",[t("li",[i._v("wait：notify 随机唤醒一个线程，notifyAll 唤醒所有等待的线程")]),i._v(" "),t("li",[i._v("park：unpark 唤醒指定的线程")]),i._v(" "),t("li",[i._v("Condition：signal 随机唤醒一个线程，signalAll 唤醒所有等待的线程")])])]),i._v(" "),t("li",[t("p",[i._v("执行顺序")]),i._v(" "),t("ul",[t("li",[i._v("park：unpark 可以在 park 前执行。可以先调用 unpark 方法释放一个许可证，后面线程调用 park 方法时，发现已经许可证了，就可以直接获取许可证而不用进入休眠状态了")]),i._v(" "),t("li",[i._v("wait/notify：保证 wait 方法比 notify 方法先执行。如果 notify 方法比 wait 方法晚执行的话，就会导致因 wait 方法进入休眠的线程接收不到唤醒通知的问题")]),i._v(" "),t("li",[i._v("Condition：保证 wait 方法比 signal 方法先执行。")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);