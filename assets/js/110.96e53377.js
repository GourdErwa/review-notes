(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{482:function(t,a,s){"use strict";s.r(a);var r=s(10),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("专栏原创出处："),s("a",{attrs:{href:"https://github.com/GourdErwa/review-notes/tree/master/framework/spark-basis",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源笔记文件 "),s("OutboundLink")],1),t._v(" ，"),s("a",{attrs:{href:"https://github.com/GourdErwa/spark-advanced",target:"_blank",rel:"noopener noreferrer"}},[t._v("github-源码 "),s("OutboundLink")],1),t._v("，欢迎 Star，转载请附上原文出处链接和本声明。")])]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#_1-什么是分区"}},[t._v("1. 什么是分区")])]),s("li",[s("a",{attrs:{href:"#_2-分区方式"}},[t._v("2. 分区方式")]),s("ul",[s("li",[s("a",{attrs:{href:"#_1-hashpartitioner"}},[t._v("1.HashPartitioner")])]),s("li",[s("a",{attrs:{href:"#_2-rangepartitioner"}},[t._v("2.RangePartitioner")])])])]),s("li",[s("a",{attrs:{href:"#_3-如何设置合理的分区数"}},[t._v("3. 如何设置合理的分区数")])])])]),s("p"),t._v(" "),s("h2",{attrs:{id:"_1-什么是分区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是分区"}},[t._v("#")]),t._v(" 1. 什么是分区")]),t._v(" "),s("p",[t._v("RDD 是一个分布式的数据集，会存放很大量的数据，一个 RDD 是由若干个分区组成的，对 RDD 进行的各种操作，实际上就是对 RDD 中的分区并行的操作。因此，合理的控制分区数，可以更有效的利用集群的计算资源，减少网络传输上的开销，提升整体性能。")]),t._v(" "),s("h2",{attrs:{id:"_2-分区方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-分区方式"}},[t._v("#")]),t._v(" 2. 分区方式")]),t._v(" "),s("p",[t._v("数据的分区方式只作用于 <key,value> 形式的 RDD。因此，当对一个 RDD 使用 shuffle 类型的算子的时候，这时就会用到数据分区器。")]),t._v(" "),s("p",[t._v("spark 默认提供了两种分区器，一种是 HashPartitioner，另一种是 RangePartitioner；还可以自定义分区器，通过继承 Partitioner 抽象类来实现。")]),t._v(" "),s("h3",{attrs:{id:"_1-hashpartitioner"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-hashpartitioner"}},[t._v("#")]),t._v(" 1.HashPartitioner")]),t._v(" "),s("p",[t._v("采用哈希的方式对 <key,value> 形式的 RDD 进行分区，首先根据 key 值计算出 hashCode，然后再除以分区数取余，最后的到的结果就是这个 key 对应的分区 Id。")]),t._v(" "),s("p",[t._v("HashPartitioner 分区的方式有可能会造成数据倾斜，如果有大量的数据取余后得到的分区 Id 都相同，那么这些数据会放到一个分区中，因此生成的 Task 在运行的时候也会比其他的 Task 耗时要长很多。")]),t._v(" "),s("div",{staticClass:"language-scala extra-class"},[s("pre",{pre:!0,attrs:{class:"language-scala"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" HashPartitioner"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("partitions"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" Partitioner "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  require"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("partitions "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Number of partitions ($partitions) cannot be negative."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" numPartitions"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" partitions\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 获取分区 Id 的方法")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果 key 是 null 的话得到的分区 id 是 0")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// key 不为 null 得到的 id = key.hashCode % numPartitions")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" getPartition"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" key "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" _ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v(" Utils"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nonNegativeMod"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hashCode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" numPartitions"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("override")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" equals"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("other"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Boolean")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" other "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("match")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" h"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" HashPartitioner "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v("\n      h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("numPartitions "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" numPartitions\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" _ "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("=>")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("override")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" hashCode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" numPartitions\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_2-rangepartitioner"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-rangepartitioner"}},[t._v("#")]),t._v(" 2.RangePartitioner")]),t._v(" "),s("p",[t._v("RangePartitioner 可以解决 HashPartitioner 有可能会产生的数据倾斜问题，尽量保证分配到每个分区的数据是均匀的，它会将一个范围内的数据分配到一个分区中。")]),t._v(" "),s("p",[s("strong",[t._v("RangePartitioner 工作原理：")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("首先根据子 RDD 分区的数量计算所需采样的总数据量：每个分区采样 20 条数据，所有分区最多采集 1000000 条数据。")])]),t._v(" "),s("li",[s("p",[t._v("然后计算对父 RDD 每个分区需要采样的平均据量：将要采样的总数据量扩容 3 倍 (防止采样的时候产生数据倾斜)，然后再除以父 RDD 的分区数，采样的方式是使用水库采样。")])]),t._v(" "),s("li",[s("p",[t._v("采样完成后对每个分区采样的数据量进行判断，如果大于先前计算好的平均数据量 (已经进行了 3 倍扩容)，说明这个分区采样的数据不均衡，需要使用 sample 算子对这些分区重新采样。")])]),t._v(" "),s("li",[s("p",[t._v("首次采样数据分布均匀的以及分布不均匀进行二次采样的分区，最终都会得到每个分区中所有采样的 key，和这个 key 所占的权重。")])]),t._v(" "),s("li",[s("p",[t._v("通过 determineBounds() 方法，求出这些 key 的平均权重，然后将这些 key 排序，按顺序依次相加每一个 key 的权重，每当达到平均权重的 1 倍、2 倍、3 倍 ··· 的时候，将最后相加的权重对应的 key 值放入一个数组 rangeBounds 中，作为划分每个分区边界的标记。")])]),t._v(" "),s("li",[s("p",[t._v("获取分区 Id 时，如果 rangeBounds 数组长度大于 128 则采用二分法找到 RDD 中的 key 对应的分区 Id，否则按顺序查找对应的分区 Id。")])])]),t._v(" "),s("blockquote",[s("p",[t._v("由于代码量比较多，此处不粘贴源码，相关源码可以参考 RangePartitioner 类。")])]),t._v(" "),s("h2",{attrs:{id:"_3-如何设置合理的分区数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何设置合理的分区数"}},[t._v("#")]),t._v(" 3. 如何设置合理的分区数")]),t._v(" "),s("ol",[s("li",[t._v("分区数越多越好吗？")])]),t._v(" "),s("p",[t._v("不是的，分区数太多意味着任务数太多，每次调度任务也是很耗时的，所以分区数太多会导致总体耗时增多。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("分区数太少会有什么影响？")])]),t._v(" "),s("p",[t._v("分区数太少的话，会导致一些结点没有分配到任务；另一方面，分区数少则每个分区要处理的数据量就会增大，从而对每个结点的内存要求就会提高；还有分区数不合理，会导致数据倾斜问题。")]),t._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[t._v("合理的分区数是多少？如何设置？")])]),t._v(" "),s("p",[t._v("总核数=executor-cores * num-executor")]),t._v(" "),s("p",[t._v("一般合理的分区数设置为总核数的 2~3 倍")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:"https://blog-review-notes.oss-cn-beijing.aliyuncs.com/gourderwa.footer.jpeg"}})])])}),[],!1,null,null,null);a.default=e.exports}}]);